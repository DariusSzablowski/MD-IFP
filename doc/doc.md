# MD-IFP: MD trajectory analysis using protein-ligand Interaction Fingerprints
## A Python workflow for generation and analysis Protein-Ligand Interaction Fingerprints from Molecular Dynamics tajectories

__Authors:__

* Daria Kokh
* Fabian Ormersbach - preprocessing PDB files using Chimera (Process_pdb.py, chimera_hydrogen_mol2.py; test examples revised) 


Heidelberg Institute of Theoretical Studies (HITS, www.h-its.org)

Schloss-Wolfsbrunnenweg 35

69118 Heidelberg, Germany
    

*This open source software code was developed in part in the __Human Brain Project__, funded from the European Unionâ€™s Horizon 2020 Framework Programme for Research and Innovation under Specific Grant Agreements  No. 785907 (Human Brain Project  SGA2).*


# __I. Important notes regarding the file preparation procedure for IFP computations:__

## Ligand structure
  1. __Ligand must be protonated__. For analysis of multiple structures, one can use the automated procedure implemented in the script Process_pdb.py that employs the Chimera software (https://www.cgl.ucsf.edu/chimera/). 
  2. The ligand structure should be provided as a  __MOL2 file__. However, not all mol2 formats are accepted by RDKit (the Python library that is used to determine ligand atom properties). The main problem with mol2 files generated by Chimera is that it often incorrectly describes bonds in aromatic or cyclic groups that contain nitrogen atoms. The mol2 file generated can in some cases be corrected by using http://www.swissparam.ch/. The best way to generate a mol2 file is to use the MOE or Maestro software.
  3. If mol2 file is absent or is not accepted by RDKit, pdb file will be used to define properies of ligand atoms. Unfortunately, in this case aromatic fragments will not be identified.
  4. There are several atom properties that are introduced in addition to those identified by RDKit:
      - Hydrophobic properties of fluorine atoms
      -  Negative ion property of the phosphate atom
      -  Acceptor property of the oxygen atoms bound to phosphorus atoms in phosphate groups
  5. __Important__, the name of the ligand in mol2 file (or the residue name in the pdb file if mol2 is absent) is used to detect ligand in a trajectory or in a complex. If the residue name is different - IFP will not be computed!
  6. __Important__: sometimes RDkit does not recognize ligand properties correctly, they can be checked and corrected if necessary:
  
    #  reading ligand input file and generating ligand chemical properties :
    my_ligand = Ligand("./",ligand_pdb,ligand_mol2)
    properties = my_ligand.property_list
    #  checking properties
    print("Ligand properties: ",properties
    #...............Ligand properties:................
    # Acceptor ['O09', 'O12']
    # PosIonizable ['N02']
    # Hydrophobe ['C14', 'C06', 'C07']
    #   correcting properties: let define atom N02 as one more  acceptor atom, for this we can re-define properties['Acceptor'] as:
    properties['Acceptor'] = ['O09', 'O12','N02']
    # then we can run IFP generation as usual, passing new properties as an input parameter:
    df_prop,df_HB,df_WB = IFP(u_mem, sel_ligands, properties, WB_analysis=True)
  
 ## Complex structure/trajectory 
   1. __System (protein/ligand/water) must be protonated__. This is nessesary for detection of hydrogen bonds.
   2. __Finding ligand contacts with ions/RNA/etc__.To minimize the memory and computational time required, only a part of the system is analyzed (defined by a variable sub_system). By default, this is protein+water+ligand. Interactions (H-bonds) with DNA/RNA and ions can be found only if their residues are explicitly defined in by the sub_system variable of the trajectories class. Alternatively, one can speed-up computqtions by keeping only protein as a sub_system. For example:
     
     # by default protein, ligand and water are considered
     # consider only protein and ligand 
     tr = trajectories()
     tr.sub_system = " proteins "
     tr.analysis_all_namd()
     
     # consider only protein, water, ligand, RRN, and some ions
     tr = trajectories()
     tr.sub_system = "protein or (resname G G3 G5 U5 C C3 MG MN CA Mg Mn) or (resname WAT HOH SOL)"
     tr.analysis_all_namd()

   
   3. For computation of IFP in a trajectory, protein (reference) structure in a pdb format must be provided in addition to a trajectory file. It must have the same structure. Note, that RMSD computed will be relative to the reference structure (not the first frame).
   4. Currently, Gromacs trajectories (as xtc) must be pre-processed in order to build back molecules that can be splitted due to the motion under PBC. Trajectory analysis does not do this properly (to be fixed in future) One can use the following command:
   
    gmx trjconv -f ramd_trj.xtc  -s ramd_tpr.tpr  -pbc mol -o ramd_trj_fixed.xtc  <<< 0
    or to save only starting from 500ps:
    gmx trjconv -f ramd_trj.xtc  -s ramd_tpr.tpr  -pbc mol -o ramd_trj_fixed.xtc  -b + 500 <<< 0
    
   
   
 # __II. Structure of the MD-IFP library:__

## A set of  Python scripts  collected in the directory Scripts

   1. Trajectories.py
   2. IFP_generation.py
   3. Clustering.py
   
  
 # __III. Generation of the Interaction Fingerprint table for a set of MD trajectories obtained either from standard MD simulations or RAMD simulations__
Most steps included in the present examples are also demonstrated in the JN IFP_generation_examples_TRAJ.ipynb
However, to analyze a large set of trajectories a simple python script is usually more useful.

This example provide a template script that, after small adjustment, can be used to generate IFPs for: 
- a single MD trajectory    
- a set of MD trajectories. 
- a set of Equilibration MD trajectories and dissociation RAMD trajectries
    
    
    
All steps are also included in IFP.py, that can be adjusted for a particular task

1. **Prerequisite:**
    - Python 3.X and a set of python libraries
        Alteratively, one can configure environment in anaconda using: conda env create -f IFP_trajectory.yml
    - Scripts directory containing Scripts/IFP_generation.py and Scripts/Trajectories.py 
    
2. **Input data required:**
    - trajectory file (possible formats: nc,dcd, xtc, trr )
    - pdb file of the system (for example, generated from the first frame)
    - ligand pdb file
    - ligand mol2 file (not all mol2 files can be read, files generated by MOE or corrected by http://www.swissparam.ch/ are usually fine)
         
3. **Procedure (all steps are also combined in the IFP.py script that can be adapted for a particular task )**
 
    (i) _working directory and template of trajectory names that will be searched and added to the object are defined._
    
        for example, simulated equilibration and dissociation trajectories can be stored as follows:
        >>for equilibration:
        
        my_ligand/my_equilibration/my_replica1/md1.dcd
        my_ligand/my_equilibration/my_replica2/md2.dcd
        
        >>for dissociation:
        
        my_ligand/my_RAMD/my_replica1/my_trajectory1/md1.dcd
        my_ligand/my_RAMD/my_replica1/my_trajectory2/md2.dcd
        
        my_ligand/my_RAMD/my_replica2/my_trajectory1/md1.dcd
        my_ligand/my_RAMD/my_replica2/my_trajectory2/md2.dcd
        
        >>reference pdb file for the system: 
        
        my_ligand/topology/my_ref.pdb
        
        >>mol2 and pdb files for the ligand:

        my_ligand/topology/my_ligand.pdb
        my_ligand/topology/my_ligand.mol2
  
    In this case we define input parameters as following:
    
    __________________________________
    
        DIR_all = "my_ligand/"
        eq = "my_equilibration/my_replic*"
        ramd = "my_RAMD/my_replic*"
        eq_tr ="my_trajec*/*.dcd"
        ramd_tr = "my_trajec*/*.dcd"
     __________________________________
     
     Note, that the reference pdb file for a complete system  and pdb/mol2 for a ligand are obligatory, while equilibration or RAMD trajectory can be omitted
   
    (ii)_Trajectory object is generated_, 
    
    which contains all information of equilibration and RAMD trajectories. 
    Additionally, ligand structure and chemical properties will be analyzed
    
     __________________________________
     
        tr = trajectories(DIR_all,namd_tmpl= eq, ramd_tmpl= ramd,ligand_pdb=lig_pdb,pdb = ref_pdb,\
                          ligand_mol2=lig_mol2,namd_traj_tmpl = eq_tr,ramd_traj_tmpl = tamd_tr)                   
      __________________________________
      
     (iii) _Defenition of a sub-system to be analyzed_ 
     
      - several possibilities are demonstrated below. 
      - Ligand will be added automatically to any chosen sub-system; 
      - by default only protein will be considered as a sub-system this makes simulations fast, but computations of water bridges will be not possible
      - Inclusion water makes simulations notably (at least several times) slower
     __________________________________
                               
        tr.sub_system = " protein  "                                              # only protein and ligand - default set
        tr.sub_system = " protein or (resname SOL HOH WAT G G3 G5 U5 C C3 MN)  "  # protein, ligand, solvent, RNA residues, and Mn ion
        tr.sub_system = " protein or (resname SOL HOH WAT )  "                    # protein, ligand, solvent, 
     __________________________________
     
   (iv) _IFP generation_ 
   
   (a) _for equilibration trajectories:_ 
      - One can define if water bridges must be computed (WB_analysis = True/False, default-False). 
        For computation of water bridges  water must be included in the sub-system in the previous step
      - number of contacts with lipids (ligand atom-residue distance < 5A) can be computed - lipid residue names are defined as a list, 
        for example: Lipids = ["PC","CHL","PA"]
      - first frame and stride are defined by the parameters step_analysis and start_analysis
        Saving results  in a data frame file (pkl)         
      - as an input parameter file name should be given 
      - results will be stored in a set of pandas DataFrames - individual frame for each trajectory-  tr.namd.traj.df_properties
      - a complete IFP table can be stored as a pkl file using tr.namd.IFP_save() function with a single parameter- file name
        this  function will return a complete pandas DataFrame including all trajectories
     __________________________________
     
        tr.analysis_all_namd(WB_analysis = False, Lipids = [],auxi_selection = [],step_analysis=step, start_analysis=start)  
        IFP_table = tr.namd.IFP_save(file_name)
      _________________________________
     
   (b) _for RAMD trajectories_
      - first relative residence times will be computed (if the number of RAMD trajectories is more than 8)  using the scan_ramd() function
      - then IFPs computed using the function , similar to that described above for equilibration trajectory
        parameters are the same as for the IFP generation for equilibration trajectories
     __________________________________   

        tr.ramd.scan_ramd()
        tr.analysis_all_ramd(WB_analysis = False, Lipids = [],auxi_selection = [],step_analysis=step, start_analysis=start)
        IFP_table = tr.namd.IFP_save(file_name)
        

 # __IV. A possible way to obtain representative structures of each cluster from RAMD dissociation trajectories__
 
The final dataframe df_ext (step 6 in the ) contains information which trajectory/frame belong to which cluster: cluster number is stored in the column "label"; trajectory frame is in the column "time" (note, that it is not a frame number of the complete original trajectory, but a frame number in the last N frames used to generate IFPs), replica name and the trajectory number are in columns "Repl" and "Traj", respectively.
The main problem is to figure out how the values "Repl", "Traj", and "time" are associated with a real frame and a real RMAD trajectory.
Unfortunately, this info is not stored in the IFP dataframe and to answer this question one has to do some additional analysis.

